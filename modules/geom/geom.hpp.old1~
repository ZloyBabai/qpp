#ifndef _QPP_GEOM_H
#define _QPP_GEOM_H

#include <lace/lace3d.hpp>
#include <lace/lace.hpp>
#include <symm/symm.hpp>
#include <vector>
#include <cmath>
#include <io/qppdata.hpp>
#include <geom/atom.hpp>

#ifdef __GXX_EXPERIMENTAL_CXX0X__
#include <initializer_list>
#endif

namespace qpp{

  //fixme - bring all numeric constansts and tolerance thresholds to one place
  double symmtol = 1e-5;

  //--------------------------------------------------------------//

  // The struct to store 1, 2 or 3 translation vectors
  template<int DIM,class VALTYPE=double, class charT = char, class traits = std::char_traits<charT> >
  struct periodic_cell :  public qpp_object<charT,traits>{
    lace::vector3d<VALTYPE> v[DIM];

    using typename qpp_object<charT,traits>::string;

    string _name;

    periodic_cell(string __name = "")
    {
      _name = __name;
    }

    periodic_cell(VALTYPE a, VALTYPE b, VALTYPE c,
		  VALTYPE alpha, VALTYPE beta, VALTYPE gamma, string __name = "")
    // for DIM==3
    {
      v[0] = lace::vector3d<VALTYPE>(a,VALTYPE(0),VALTYPE(0));
      v[1] = lace::vector3d<VALTYPE>(b*std::cos(gamma), b*std::sin(gamma),
				     VALTYPE(0));
      VALTYPE nx = std::cos(beta);
      VALTYPE ny = (std::cos(alpha) - nx*std::cos(gamma))/std::sin(gamma);
      VALTYPE nz = std::sqrt(1-nx*nx-ny*ny);
      v[2] = lace::vector3d<VALTYPE>(nx,ny,nz)*c;

      _name = __name;
    }

    inline lace::vector3d<VALTYPE> & operator()(int i)
    { return v[i]; } 

    inline VALTYPE & operator()(int i, int j)
    { return v[i](j); }
    
    inline lace::vector3d<VALTYPE> frac2cart(lace::vector3d<VALTYPE> frac) const
    // transforms fractional coordinates to cartesian
    // Works for any DIM, but the vector frac still should be 3d
    // if DIM<3, frac(i) components with i>=DIM are not used
    { 
      lace::vector3d<VALTYPE> res=VALTYPE(0);
      for (int i=0; i<DIM; i++)
    	res+=frac(i)*v[i];
      return res;
    }
    
    //   inline lace::vector3d<VALTYPE> frac2cart(simple_vector<VALTYPE,DIM> frac)
    // fractional to cartesian coordinates
    // works for DIM=1,2,3
    // here we use simple_vector to pass fractional coords
    //{
    //  lace::vector3d<VALTYPE> res=VALTYPE(0);
    //  for (int i=0; i<DIM; i++)
    //	res+=frac(i)*v[i];
    // return res;
    //}

    inline lace::vector3d<VALTYPE> cart2frac(lace::vector3d<VALTYPE> r) const
    // cartesian to fractional
    // works for DIM==3 only
    { 
      lace::matrix3d<VALTYPE> A(v[0],v[1],v[2]);
      return lace::solve3d(A, r);
    }

    inline lace::vector3d<VALTYPE> reduce(lace::vector3d<VALTYPE> r)  const
    // Brings the point r into the volume of unit cell
    // by translations
    // unit cell is defined as parallelepiped with one vertex in
    // the coordinate origin
    // the others are pointed by v[0],v[1],v[2] vectors
    {
      lace::vector3d<VALTYPE> f = cart2frac(r);
      f(0) -= int(f(0));
      f(1) -= int(f(1));
      f(2) -= int(f(2));
      return frac2cart(f);
    }

    inline lace::vector3d<VALTYPE> reduce_cntr(lace::vector3d<VALTYPE> r) const
    // Brings the point r into the volume of unit cell
    // by translations
    // unit cell is defined as parallelepiped CENTRED in the
    // coordinate origin
    {
      lace::vector3d<VALTYPE> f = cart2frac(r);
      for (int i=0; i<3; i++)
        {
          f(i) -= int(f(i));
          if ( f(i) > VALTYPE(1)/2 ) f(i)-=1;
        }
      return frac2cart(f);
    }

    inline lace::vector3d<VALTYPE> reduce_wz(lace::vector3d<VALTYPE> r) const
    // Brings r into Wigner-Zeitz unit cell
    // fixme - implement this!
    {}

    inline bool in_cell(lace::vector3d<VALTYPE> r) const
    // Answers the question whether r belongs to the unit cell
    {
      lace::vector3d<VALTYPE> f = cart2frac(r);
      return 
        VALTYPE(0)<=f(0) && f(0) < VALTYPE(1) &&
        VALTYPE(0)<=f(1) && f(1) < VALTYPE(1) &&
        VALTYPE(0)<=f(2) && f(2) < VALTYPE(1);  
    }


    inline bool in_cell_cntr(lace::vector3d<VALTYPE> r) const
    // does r belong to unit cell centred at the coords origin?
    {
      lace::vector3d<VALTYPE> f = cart2frac(r);
      return 
        -VALTYPE(1)/2 <= f(0) && f(0) < VALTYPE(1)/2 &&
        -VALTYPE(1)/2 <= f(1) && f(1) < VALTYPE(1)/2 &&
        -VALTYPE(1)/2 <= f(2) && f(2) < VALTYPE(1)/2;   
    }

    inline bool in_cell_wz(lace::vector3d<VALTYPE> r) const
    // does r belong to Wigner-Zeitz unit cell
    // fixme - implement this!
    {}

    virtual string category()
    {
      return "vectors";
    }

    virtual string name()
    {
      return _name;
    }

    virtual int gettype()
    {
      int d;
      if (DIM==0)
	d = qppdata_dim0;
      else if (DIM==1)
	d = qppdata_dim1;
      else if (DIM==2)
	d = qppdata_dim2;
      else if (DIM==3)
	d = qppdata_dim3;
      return qppdata_vectors | d;
    }

    virtual void write(std::basic_ostream<charT,traits> &os, int offset=0)
    {
      for (int k=0; k<offset; k++) os << " ";
      os << "vectors";
      if (_name != "")
	os << " " << _name;
      os << "(" << DIM << "d){\n";

      for (int i=0; i<DIM; i++)
	{
	  for (int k=0; k<offset+2; k++) os << " ";
	  os << boost::format(" %11.6f %11.6f %11.6f\n") % v[i](0) % v[i](1) % v[i](2);	  
	}

      for (int k=0; k<offset; k++) os << " ";
      os << "}\n";
    }

  };

  // ------------------- index class ----------------------
  // Index is a handy tool to reference atoms in this geometry
  // as well as atoms in neighbouring cells
  // For that purpose it is a complex index - it contains, besides
  // the number of atom it is currently pointning at, also the 
  // indicies of the cell.
  template <int DIM>
  class index{
  protected:
    int at;
    int cll[DIM];    
    
  public:
    inline index& operator=(int _at)
    {
      at=_at;
      if (DIM>0)
	cll[0]=0;
      if (DIM>1)
	cll[1]=0;
      if (DIM>2)
	cll[2]=0;
      return *this;
    }
    
    //      inline operator int(){return at;}
    
    inline int atom(){return at;}
    
    inline int cell(int d){return cll[d];}
    
    inline void set(int _at, int i1=0, int i2=0, int i3=0)
    {
      at=_at;
      if (DIM>0)
	cll[0]=i1;
      if (DIM>1)
	cll[1]=i2;
      if (DIM>2)
	cll[2]=i3;
    }
    
    inline void setatom(int _at){at=_at;}
    
    inline void setcell(int d, int i){cll[d]=i;}
    
    index(){
      //	_check();
      set(0);
    }
    
    index(int _at, int i1=0, int i2=0, int i3=0)
    {
      //	_check();
      set(_at,i1,i2,i3);
    }      
    
    inline bool operator==(index<DIM> i)
    {
      if (DIM==0)
	return at == i.at;
      else if (DIM==1)
	return at == i.at && cll[0] == i.cll[0];
      else if (DIM==2)
	return at == i.at && cll[0] == i.cll[0] && cll[1] == i.cll[1];
      else if (DIM==3)
	return at == i.at && cll[0] == i.cll[0] && cll[1] == i.cll[1] && cll[2] == i.cll[2];
    }
    
  };

  //--------------------------------------------------------------//


  // The geometry class stores atoms together with their
  // coordinates. As ATOM is a template parameter, you can
  // use almost everything as POINT, even emply class.
  //
  // In this latter case you get just points with coordinates
  // Such object can be used to store, say, displacement 
  // vectors or vibrational mode vectors.
  //
  // If ATOM is something more substatial, you can store any information
  // about atoms as well

  // geometry is an ancestor for molecule
  template<class ATOM, int DIM, class VALTYPE, class charT = char, class traits = std::char_traits<charT> >
  class geometry : public qpp_object<charT,traits>{

  protected:

    int nat;
    // Number of atoms/points

    std::vector<ATOM> atm;
    // Storage of atoms

    std::vector<lace::vector3d<VALTYPE> > crd;
    // Their coordinates

    using typename qpp_object<charT,traits>::string;

    string _name;

  public:
    periodic_cell<DIM,VALTYPE> cell;
    // Unit cell vectors for 1,2,3d periodicity

    // ------------------- iterator class --------------------
    // Iterator allows you run through all (or some) atoms of this cell
    // and of surrounding cells
        
    class iterator : public index<DIM>{

      index<DIM> a, b;
      // a - from
      // b - to

      using index<DIM>::at;
      using index<DIM>::cll;

    public:

      iterator(const geometry<ATOM,DIM,VALTYPE> &g)
      // default iterator goes through neighbouring cells only
      {
	a.setatom(0);
	for (int d=0; d < DIM; d++)
	  a.setcell(d,-1);
	b.setatom(g.nat - 1);
	for (int d=0; d < DIM; d++)
	  b.setcell(d,1);	
      }

      iterator(index<DIM> _a, index<DIM> _b)
      {
	a = _a;
	b = _b;
      }

      inline index<DIM> begin(){return a;}

      //      inline index end(){return b;}

      inline index<DIM> end(){return index<DIM>(-1,0,0,0);}

      inline iterator& operator=(index<DIM> i)
      {
	at = i.atom();
	for (int d = 0; d<DIM; d++)
	  cll(d) = i.cell(d);
      }

      inline bool operator==(index<DIM> i)
      {
	bool res = (at == i.atom());
	if (res)
	  for (int d = 0; d<DIM; d++)
	    if ( cll(d) != i.cell(d) ) 
	      {
		res = false;
		break;
	      }
	return res;
      }

      inline bool operator!=(index<DIM> i)
      {
	if (DIM==0)
	  return at != i.atom();
	else if (DIM==1)
	  return at != i.atom() || cll(0) != i.cell(0);
	else if (DIM==2)
	  return at != i.atom() || cll(0) != i.cell(0) || cll(1) != i.cell(1);
	else if (DIM==3)
	  return at != i.atom() || cll(0) != i.cell(0) || cll(1) != i.cell(1) || cll(2) != i.cell(2);
      }
               
      iterator& operator++(int)      
      {
	if (*this == b)
	  {
	    *this = end();
	    return *this;
	  }

	at++;
	if (at > b.atom() && DIM>0)
	  {
	    at=a.atom();
	    int d=0;
	    while(d < DIM)
	      {
		cll(d)++;
		if (cll(d) > b.cell(d))
		  {
		    for(int dd=0; dd<=d; dd++)
		      cll(d) = a.cell(dd);
		    d++;
		  }
		else 
		  break;
	      }
	  }
	return *this;

      }  

    };

    // ---------------------------------------------------------
  public:

    geometry(string __name = ""){nat=0; _name = __name;}

    geometry(lace::vector3d<VALTYPE> v1, lace::vector3d<VALTYPE> v2=0e0, 
	     lace::vector3d<VALTYPE> v3=0e0, string __name = "")
    {
      if (DIM>0)
	cell(0)=v1;
      if (DIM>1)
	cell(1)=v2;
      if (DIM>2)
	cell(2)=v3;
      nat = 0;
      _name = __name;
    }

    virtual string category()
    {
      return "geometry";
    }

    virtual string name()
    {
      return _name;
    }

    virtual int gettype()
    {
      int d;
      if (DIM==0)
	d = qppdata_dim0;
      else if (DIM==1)
	d = qppdata_dim1;
      else if (DIM==2)
	d = qppdata_dim2;
      else if (DIM==3)
	d = qppdata_dim3;
      return qppdata_geometry | d;
    }

    virtual void add_point(ATOM a, const lace::vector3d<VALTYPE> & r)
    {
      atm.push_back(a);
      crd.push_back(r);
      nat++;
    }

    virtual void add_point(ATOM a, VALTYPE _x, VALTYPE _y, VALTYPE _z)
    {
      atm.push_back(a);
      crd.push_back(lace::vector3d<VALTYPE>(_x,_y,_z));
      nat++;
    }

    virtual void del_point(const int i)
    {
      atm.erase(atm.begin()+i);
      crd.erase(crd.begin()+i);
      nat--;
    }

    virtual void insert_point(const int i, ATOM a, const lace::vector3d<VALTYPE> &r)
    {
      atm.insert(atm.begin()+i,a);
      crd.insert(crd.begin()+i,r);
      nat++;
    }
    
    virtual void insert_point(const int i, ATOM a, const VALTYPE _x, const VALTYPE _y, const VALTYPE _z)
    {
      atm.insert(atm.begin()+i,a);
      crd.insert(crd.begin()+i,lace::vector3d<VALTYPE>(_x,_y,_z));
      nat++;
    }

    inline int size(){return crd.size();}

    inline ATOM& atom(index<DIM> i){return atm[i.atom()];}

    // coord gives the coordinates of i-th atom in the cell
    inline lace::vector3d<VALTYPE>& coord(int i){return crd[i];}

    // Unlike coord(i), full_coord(i) gives the coordinates of either
    // this atom in this unit cell or the coordinates of its image
    // in neighbouring cells
    // In other words
    // coord(i) = cell_coord(i) + atom_coord(i)
    inline lace::vector3d<VALTYPE> full_coord(index<DIM> i)
    {
      if (DIM==0)
	return crd[i.atom()];
      if (DIM==1)
	return crd[i.atom()] + cell(0)*i.cell(0);
      if (DIM==2)
	return crd[i.atom()] + cell(0)*i.cell(0) 
	  + cell(1)*i.cell(1);
      if (DIM==3)
	return crd[i.atom()] + cell(0)*i.cell(0) 
	  + cell(1)*i.cell(1) + cell(2)*i.cell(2);
    }    

    inline lace::vector3d<VALTYPE> cell_coord(int i1=0, int i2=0, int i3=0)
    {
      lace::vector3d<VALTYPE> r=0e0;
      if (DIM>0)
	r += i1*cell(0);
      if (DIM>1)
	r += i2*cell(1);
      if (DIM>2)
	r += i3*cell(2);
      return r;
    } 

    void scale(VALTYPE s)
    {
      for (int i=0; i<DIM; i++)
	cell(i) *= s;
      for (int i=0; i<nat; i++)
	crd[i] *= s;
    }

    void clear()
    {
      crd.clear();
      atm.clear();
      nat = 0;
    }

    virtual void write(std::basic_ostream<charT,traits> &os, int offset=0)
    {
      for (int k=0; k<offset; k++) os << " ";
      os << "geometry";
      if (_name != "")
	os << " " << _name;
      os << "(" << DIM << "d){\n";

      for (int i=0; i<size(); i++)
	{
	  for (int k=0; k<offset+2; k++) os << " ";
	  os << nameofatom(atm[i]) << boost::format(" %11.6f %11.6f %11.6f\n") % crd[i].x() % crd[i].y() %crd[i].z();
	  
	}

      for (int k=0; k<offset; k++) os << " ";
      os << "}\n";
    }

  };


  // ---------------- Geometry with extra fields - for storing any additional data -------------------

  template<class ATOM, int DIM, class VALTYPE, class charT = char, class traits = std::char_traits<charT> >
  class xtr_geometry : public geometry<ATOM,DIM,VALTYPE,charT,traits>{
  
    std::vector<VALTYPE> chrg;

    std::vector<std::vector<VALTYPE> >  _xtr_real;
    std::vector<std::vector<int> >      _xtr_int;
    std::vector<std::vector<short> >    _xtr_bool;

    int nxreal, nxint, nxbool;
    bool xchrg;

    using geometry<ATOM,DIM,VALTYPE,charT,traits>::atm;
    using geometry<ATOM,DIM,VALTYPE,charT,traits>::crd;
    using geometry<ATOM,DIM,VALTYPE,charT,traits>::size;
    using geometry<ATOM,DIM,VALTYPE,charT,traits>::_name;
    using typename geometry<ATOM,DIM,VALTYPE,charT,traits>::string;

  public:

    xtr_geometry(bool charge = true, int n_xtr_real=0, int n_xtr_int=0, int n_xtr_bool=0, string __name = "") :
      _xtr_real(n_xtr_real), _xtr_int(n_xtr_int), _xtr_bool(n_xtr_bool), geometry<ATOM,DIM,VALTYPE,charT,traits>(__name)
    {
      xchrg = charge;
      nxreal = n_xtr_real;
      nxint = n_xtr_int;
      nxbool = n_xtr_bool;
    }

    virtual int gettype()
    {
      return geometry<ATOM,DIM,VALTYPE,charT,traits>::gettype() | qppdata_xgeom;
    }

    /*    ~xtr_geometry()
    {
      std::cout << "destructor\n";
      std::cout << "  real\n";
      if (nxint>0)
	delete _xtr_int;
      std::cout << "  int\n";
      if (nxbool>0)
	delete _xtr_bool;
      std::cout << "  bool\n";
      }*/

    VALTYPE & xtr_real(int i, int j)
    {
      return _xtr_real[j][i];
    }

    int & xtr_int(int i, int j)
    {
      return _xtr_int[j][i];
    }

    bool & xtr_bool(int i, int j)
    {
      return * ((bool*) & _xtr_bool[j][i]);
    }

    VALTYPE & charge(int i)
    {
      return chrg[i];
    }

    virtual void add_point(ATOM a, const lace::vector3d<VALTYPE> & r)
    {
      geometry<ATOM,DIM,VALTYPE,charT,traits>::add_point(a,r);

      if (xchrg)
	chrg.push_back( VALTYPE(0) );   
      for (int i=0; i<nxreal; i++)
	_xtr_real[i].push_back( VALTYPE(0) );
      for (int i=0; i<nxint; i++)
	_xtr_int[i].push_back(0);
      for (int i=0; i<nxbool; i++)
	_xtr_bool[i].push_back( false );
    }

    virtual void add_point(ATOM a, VALTYPE _x, VALTYPE _y, VALTYPE _z)
    {
      add_point(a, lace::vector3d<VALTYPE>(_x,_y,_z));
    }

    virtual void del_point(const int j)
    {
      geometry<ATOM,DIM,VALTYPE,charT,traits>::del_point(j);
      for (int i=0; i<nxreal; i++)
	_xtr_real[i].erase(_xtr_real[i].begin()+j);
      for (int i=0; i<nxint; i++)
	_xtr_int[i].erase(_xtr_int[i].begin()+j);
      for (int i=0; i<nxbool; i++)
	_xtr_bool[i].erase(_xtr_bool[i].begin()+j);
      if (xchrg)
	chrg.erase(chrg.begin()+j);  
    }

    virtual void insert_point(const int j, ATOM a, const lace::vector3d<VALTYPE> &r)
    {
      geometry<ATOM,DIM,VALTYPE,charT,traits>::insert_point(j,a,r);

      if (xchrg)
	chrg.insert(chrg.begin()+j, VALTYPE(0) );  
      for (int i=0; i<nxreal; i++)
	_xtr_real[i].insert(_xtr_real[i].begin()+j, VALTYPE(0) );
      for (int i=0; i<nxint; i++)
	_xtr_int[i].insert(_xtr_int[i].begin()+j, 0);
      for (int i=0; i<nxbool; i++)
	_xtr_bool[i].insert(_xtr_bool[i].begin()+j, false);
    }

    virtual void insert_point(const int j, ATOM a, const VALTYPE _x, const VALTYPE _y, const VALTYPE _z)
    {
      insert_point(j,a,lace::vector3d<VALTYPE>(_x,_y,_z));
    }

#ifdef __GXX_EXPERIMENTAL_CXX0X__

    void add_point(ATOM a, const lace::vector3d<VALTYPE> & r, VALTYPE q, std::initializer_list<VALTYPE> xtr = {}, 
		   std::initializer_list<int> xti = {}, std::initializer_list<bool> xtb = {})
    {
      geometry<ATOM,DIM,VALTYPE,charT,traits>::add_point(a,r);

      if (xchrg)
	chrg.push_back( q );

      typename std::initializer_list<VALTYPE>::iterator ir = xtr.begin();
      for (int i=0; i<nxreal; i++)
	{
	  _xtr_real[i].push_back( ir == xtr.end() ? VALTYPE(0) : *ir );
	  ir++;
	}

      typename std::initializer_list<int>::iterator ii = xti.begin();
      for (int i=0; i<nxint; i++)
	{
	  _xtr_int[i].push_back( ii == xti.end() ? 0 : *ii );
	  ii++;
	}

      typename std::initializer_list<bool>::iterator ib = xtb.begin();
      for (int i=0; i<nxbool; i++)
	{
	  _xtr_bool[i].push_back( ib == xtb.end() ? false : *ib );
	  ib++;
	}
    }

    void insert_point(const int j, ATOM a, const lace::vector3d<VALTYPE> &r, VALTYPE q, std::initializer_list<VALTYPE> xtr = {}, 
		   std::initializer_list<int> xti = {}, std::initializer_list<bool> xtb = {})
    {
      geometry<ATOM,DIM,VALTYPE,charT,traits>::insert_point(j,a,r);
      if (xchrg)
	chrg.insert( chrg.begin()+j, q );

      typename std::initializer_list<VALTYPE>::iterator ir = xtr.begin();
      for (int i=0; i<nxreal; i++)
	{
	  _xtr_real[i].insert( _xtr_real[i].begin()+j, ir == xtr.end() ? VALTYPE(0) : *ir );
	  ir++;
	}

      typename std::initializer_list<int>::iterator ii = xti.begin();
      for (int i=0; i<nxint; i++)
	{
	  _xtr_int[i].insert( _xtr_int[i].begin()+j, ii == xti.end() ? 0 : *ii );
	  ii++;
	}

      typename std::initializer_list<bool>::iterator ib = xtb.begin();
      for (int i=0; i<nxbool; i++)
	{
	  _xtr_bool[i].insert( _xtr_bool[i].begin()+j, ib == xtb.end() ? false : *ib );
	  ib++;
	}
    }

#else
#warning You need to enable -std=c++11 or -std=gnu++11 to have add_point and insert_point with extra fields. Everything else is working, however.
#endif

    virtual void write(std::basic_ostream<charT,traits> &os, int offset=0)
    {
      for (int k=0; k<offset; k++) os << " ";
      os << "geometry";
      if (_name != "")
	os << " " << _name;
      os << "(" << DIM << "d,atom,x,y,z";
      if (xchrg)
	os << ",charge";
      for (int i=0; i<nxreal; i++)
	os << ",real";
      for (int i=0; i<nxint; i++)
	os << ",int";
      for (int i=0; i<nxbool; i++)
	os << ",bool";
      os << ")\n";
      for (int k=0; k<offset+2; k++) os << " ";
      os << "{\n";

      for (int i=0; i<size(); i++)
	{
	  for (int k=0; k<offset+4; k++) os << " ";
	  os << boost::format("%-5s %11.6f %11.6f %11.6f") % atm[i]->name  % crd[i].x() % crd[i].y() %crd[i].z();

	  if (xchrg)
	    os << boost::format(" %11.6f") % charge(i);
	  for (int j=0; j<nxreal; j++)
	    os <<  boost::format(" %11.6f") % xtr_real(i,j);
	  for (int j=0; j<nxint; j++)
	    os << boost::format(" %5i") % xtr_int(i,j);
	  for (int j=0; j<nxbool; j++)
	    os << boost::format(" %s") % (xtr_bool(i,j) ? "true" : "false");
	  os << "\n";
	}

      for (int k=0; k<offset+2; k++) os << " ";
      os << "}\n";
    }

  };

};

#endif
