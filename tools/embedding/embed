#!/usr/bin/python
import math,sys,os,string,json

def VectorNorm(v):
	IsVector3f(v)
	return math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
	
def VectorSum(v1,v2):
	IsVector3f(v1)
	IsVector3f(v2)
	return [v1[0]+v2[0],v1[1]+v2[1],v1[2]+v2[2]]
	
def VectorSub(v1,v2):
	IsVector3f(v1)
	IsVector3f(v2)
	return [v1[0]-v2[0],v1[1]-v2[1],v1[2]-v2[2]]

def VectorMultScalar(v,s):
	return [v[0]*s,v[1]*s,v[2]*s]
		
def IsVector3f(v):
	if not ( len(v) == 3) : 
		raise AssertionError
		
def MakeDict(strok):
	return dict(item.split("=") for item in strok.split())
		
bohr = 0.52917724924e0
au2ev = 27.211654e0

class PairPotential:
	rmin = 0
	rmax =9

	def E(self,r):
		return 0

	def dE(self,r):
		return 0

	def Energy(self,r1,r2):
		r = VectorNorm(VectorSub(r2,r1))
		if (r >= self.rmin) and (r<= self.rmax):
			return self.E(r)
		else :
			return 0
		
	def Gradient(self,r1,r2):
		vsub = VectorSub(r2,r1)
		r = VectorNorm(vsub)
		gr_vec = [0,0,0]
		if (r >= rmin) and (r<= rmax):
			gr_vec = VectorMultScalar(vsub,self.dE(r)/r)
		return gr_vec
	
	def ParseFromString(self,strok):
		return 0

class BuckinghamPotential(PairPotential):
	A = 0
	rho = 0
	C = 0
	def E(self,r):
		r3 = r*r*r
	#	print r,self.A,self.rho,self.C
		return self.A*math.exp(-r/self.rho) - self.C/(r3*r3)
	def dE(self,r):
		r3 = r*r*r
		return -self.A*math.exp(-r/self.rho)/self.rho + self.C * 6.0 / (r3*r3*r)
	def ParseFromString(self,strok):
		dico = MakeDict(strok)
		self.A = float(dico['A'])
		self.rho =  float(dico['rho'])
		self.C = float(dico['C'])
		self.rmin = float( dico['rmin'])
		self.rmax =  float(dico['rmax'])
			
class MorsePotential(PairPotential):
	D = 0
	a = 0
	r0 = 0
	def E(self,r):
		t = 1.0 - math.exp(-self.a*(r-self.r0))
		print r,self.D*t*t
		return self.D*t*t
	def dE(self,r):
		t = math.exp(-self.a*(r-self.r0))
		return 2.0*self.a*self.D*(1.0-t)*t
	def ParseFromString(self,strok):
		dico = MakeDict(strok)
		self.D = float(dico['D'])
		self.a =  float(dico['a'])
		self.r0 = float(dico['r0'])
		self.rmin = float( dico['rmin'])
		self.rmax =  float(dico['rmax'])
		
		
class SpringPotential(PairPotential):
	k = 0  
	def E(self,r):
		return self.k*r*r/2.0
	def dE(self,r):
		return k*r
	def ParseFromString(self,strok):
		dico = MakeDict(strok)
		self.k = float(dico['k'])
		self.rmin = float( dico['rmin'])
		self.rmax =  float(dico['rmax'])	

class Atom:
	pos = [0.0,0.0,0.0]
	gradient = [0.0,0.0,0.0]
	name = 'H'
	def SetAtom(self,name_,x,y,z):
		self.name = name_
		self.pos = [x,y,z]
			
def main():
	assert ((os.path.exists('EFM')) and (os.path.exists('EMBE')))
 
	f_efm = open('EFM','r')
	f_embe = open('EMBE','r') 
	
#   Reading atoms from EFM file
	f_efm_data = f_efm.read().split('\n')
	natoms = int(f_efm_data[0])
	print 'Total atoms:',natoms
	
	atoms = []
	for i in range(0,natoms):
		data = f_efm_data[i+1].split()
		atom = Atom()
		atom.pos = [float(data[1]),float(data[2]),float(data[3])]
		atom.name = data[0]
		atoms.append(atom)
	
	print 'Atoms readed from file:'
	for atom in atoms:
		print atom.name,atom.pos
	
#Read qmmm embedding data from EMBE file
	f_embd_data = f_embe.read()
	js_emb = json.loads(f_embd_data)
	groups = js_emb["group"]
	groupc = len(groups)
	
	
if __name__ == "__main__":
	main()


 
